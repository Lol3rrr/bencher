---
title: "Selecci√≥n de Ramas"
description: "Resumen de las formas de seleccionar una rama de git usando el subcomando CLI bencher run"
heading: "Selecci√≥n de Ramas con bencher run"
published: "2023-10-27T08:40:00Z"
modified: "2024-03-27T07:50:00Z"
sortOrder: 3
---

Hay varias maneras de establecer la rama del proyecto en el subcomando CLI de <code><a href="/es/docs/explanation/bencher-run/">bencher run</a></code>.
Si no se utilizan ninguna de estas opciones o banderas, entonces `main` se usa como la rama predeterminada.

<br />

### `--branch <BRANCH>`

<br />

La forma m√°s sencilla es establecer la opci√≥n `--branch` o la variable de entorno `BENCHER_BRANCH` en el slug o UUID de una rama ya existente.
Si ambos est√°n definidos, la opci√≥n `--branch` tiene prioridad sobre la variable de entorno `BENCHER_BRANCH`.

Sin embargo, si ambos est√°n ausentes o el valor proporcionado es inv√°lido, el comando `bencher run` dar√° error.
Esto no es lo m√°s conveniente en los entornos de CI/CD, donde aparecen nuevas ramas todo el tiempo.
En lugar de utilizar `--branch` o la variable de entorno `BENCHER_BRANCH`, existe una opci√≥n `--if-branch`.

<br />

### `--if-branch <BRANCH_NAME>`

<br />

La opci√≥n `--if-branch` espera un argumento de _nombre_ de rama y consulta para ver si existe una √∫nica rama con ese nombre.
Si se encuentra exactamente una rama, entonces `bencher run` procede utilizando esa rama.
De lo contrario, `bencher run` simplemente registra y sale exitosamente.

Por ejemplo, si `main` existe, entonces usar `--if-branch main` lo encontrar√≠a. Luego, `bencher run` proceder√≠a usando `main`.

La opci√≥n `--branch` entra en conflicto con la opci√≥n `--if-branch`, pero la variable de entorno `BENCHER_BRANCH` tiene prioridad sobre la opci√≥n `--if-branch`.

<br />

> üê∞ Nota: Siempre que utilices variables de entorno, estas deben ir entre comillas dobles (es decir, `--if-branch "$MY_ENV_VAR"`).

<br />

### `--else-if-branch <BRANCH_NAME>`

<br />

A menudo, al trabajar en ramas de caracter√≠sticas, ser√≠a √∫til tener datos hist√≥ricos de la rama principal o base.
Aqu√≠ es donde entra la opci√≥n `--else-if-branch`.
La opci√≥n `--else-if-branch` espera otro argumento de _nombre_ de rama.
Si `--if-branch` falla, entonces `--else-if-branch` consulta para ver si existe una √∫nica rama con ese nombre.
Si se encuentra exactamente una rama, entonces todos los datos y umbrales de esta rama de partida se copian a una nueva rama con el nombre dado a `--if-branch`.

Por ejemplo, si `feature_branch` a√∫n no existe, pero `main` s√≠ existe y tiene datos hist√≥ricos.
Entonces, al usar `--if-branch feature_branch --else-if-branch main`, se crear√° una nueva rama llamada `feature_branch`,
y tendr√≠a una copia de todos los datos y umbrales de `main`.
Luego, `bencher run` proceder√≠a usando `feature_branch`.

Tambi√©n es posible usar m√∫ltiples opciones `--else-if-branch`.
Por ejemplo, si `mia_branch` no existe, `--if-branch feature_branch --else-if-branch mia_branch --else-if-branch main`
funcionar√≠a de la misma manera que el ejemplo anterior, copiando todos los datos y umbrales de `main` y procediendo luego.

Si la consulta `--if-branch` tiene √©xito, entonces `--else-if-branch` nunca se ejecuta, y si tanto `--if-branch` como `--else-if-branch` fallan, `bencher run` simplemente registra y sale exitosamente.

<br />

> üê∞ Nota: Siempre que utilices variables de entorno, estas deben ir entre comillas dobles (es decir, `--else-if-branch "$MY_ENV_VAR"`).

<br />

### `--else-branch`

<br />

Para garantizar en todos los casos que las m√©tricas de una ejecuci√≥n se guarden, existe una bandera `--else-branch`.
La bandera `--else-branch` no toma argumentos.
Si `--if-branch` falla, entonces `--else-branch` simplemente crea una nueva rama con el nombre dado a `--if-branch`.

Por ejemplo, si `feature_branch` a√∫n no existe.
Entonces, usar `--if-branch feature_branch --else-branch`, crear√≠a una nueva rama llamada `feature_branch`,
y no tendr√≠a datos ni umbrales iniciales.
Luego, `bencher run` proceder√≠a usando `feature_branch`.

Tambi√©n es posible encadenar las tres banderas: `--if-branch`, `--else-if-branch`, y `--else-branch`.
Por ejemplo, `--if-branch feature_branch --else-if-branch main --else-branch`.

Si la consulta `--if-branch` tiene √©xito, entonces `--else-branch` nunca se ejecuta, y del mismo modo, si `--if-else-branch` tiene √©xito, entonces `--else-branch` nunca se ejecuta.
Y se espera que `--else-branch` siempre tenga √©xito y salga exitosamente.

<br />

### `--endif-branch`

<br />

La bandera `--endif-branch` funciona como una bandera opcional noop para indicar el fin de la declaraci√≥n `--if-branch`.

Es posible encadenar las cuatro banderas: `--if-branch`, `--else-if-branch`, `--else-branch`, y `--endif-branch`.
Por ejemplo, `--if-branch feature_branch --else-if-branch "$MY_ENV_VAR" --else-branch --endif-branch`.

<br />
<br />

> üê∞ ¬°Felicidades! ¬°Has aprendido todo sobre la selecci√≥n de ramas! üéâ

<br/>

<h2><a href="/es/docs/explanation/adapters/">Contin√∫a: Adaptadores de Benchmarks ‚û°</a></h2>
