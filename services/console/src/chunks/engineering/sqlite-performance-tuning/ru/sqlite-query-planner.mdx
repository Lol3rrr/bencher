import SqliteQueryPlan from "../sqlite-query-plan.mdx";

## Планировщик запросов SQLite

На сайте SQLite есть [отличная документация по планировщику запросов][sqlite query planner].
Она точно объясняет, как SQLite выполняет ваш SQL запрос,
и учит, какие индексы полезны и на что стоит обратить внимание, например, на полные сканирования таблиц.

Чтобы увидеть, как планировщик запросов выполнит мой запрос Perf,
мне нужно было добавить новый инструмент в мой арсенал: [`EXPLAIN QUERY PLAN`][eqp]
Вы можете либо добавить к вашему SQL запросу префикс `EXPLAIN QUERY PLAN`
или выполнить команду `.eqp on` перед вашим запросом.
В любом случае, я получил результат, который выглядит так:

<SqliteQueryPlan />

О, боже!
Здесь много информации.
Но три главные вещи, которые бросились мне в глаза:

1. SQLite создает материализованное представление на лету, которое сканирует _всю_ таблицу `boundary`
2. После этого SQLite сканирует _всю_ таблицу `metric`
3. SQLite создает два индекса на лету

И каковы размеры таблиц `metric` и `boundary`?
Оказывается, это две самые большие таблицы,
так как именно в них хранятся все [Метрики][metrics] и [Границы][thresholds].

Поскольку это был мой первый опыт настройки производительности SQLite,
я хотел проконсультироваться с экспертом, прежде чем вносить какие-либо изменения.

[sqlite query planner]: https://www.sqlite.org/queryplanner.html
[eqp]: https://www.sqlite.org/eqp.html

[thresholds]: /ru/docs/explanation/thresholds/
[metrics]: /ru/docs/explanation/benchmarking/#metrics