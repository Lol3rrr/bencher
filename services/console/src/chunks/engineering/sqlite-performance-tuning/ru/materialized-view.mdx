import MetricTable from "../metric-table.mdx";
import BoundaryTable from "../boundary-table.mdx";
import MetricBoundaryView from "../metric-boundary-view.mdx";

## Материализованное представление

Когда я добавил возможность отслеживать и визуализировать [Пороговые Границы][thresholds] в прошлом году, 
мне нужно было принять решение по модели базы данных.
Между метрикой и соответствующей ей границей существует отношение 1 к 0/1. 
То есть метрика может быть связана с нулем или одной границей, и граница может быть связана только с одной метрикой. 
Я мог бы просто расширить таблицу `metric`, включив в нее все данные `boundary` с возможностью установки каждого поля связанного с `boundary` в NULL. 
Или я мог создать отдельную таблицу `boundary` с `UNIQUE` внешним ключом к таблице `metric`. 
Для меня последний вариант показался намного чище, и я подумал, что смогу всегда разобраться с любыми последствиями для производительности позже.

Это были актуальные запросы, использованные для создания таблиц `metric` и `boundary`:

<MetricTable />

<BoundaryTable />

И оказалось, что "позже" наступило. 
Я попытался просто добавить индекс для `boundary(metric_id)`, но это не помогло. 
Я считаю, что причина заключается в том, что запрос Perf исходит из таблицы `metric`, 
и поскольку эта связь 0/1, или другими словами, nullable, ее необходимо сканировать (O(n)), 
а не искать (O(log(n))).

У меня остался один ясный вариант. 
Мне нужно было создать материализованное представление, которое "разгладило" бы отношение между `metric` и `boundary`, 
чтобы SQLite не приходилось создавать его на лету.

Это запрос, который я использовал для создания нового материализованного представления `metric_boundary`:

<MetricBoundaryView />

С этим решением я обмениваю пространство на производительность выполнения. 
Сколько пространства? 
Удивительно, но только около 4% увеличения, хотя это представление для двух самых больших таблиц в базе данных. 
И самое главное, это позволяет мне иметь все и сразу в моем исходном коде.

[Создание материализованного представления с Diesel][diesel view] оказалось удивительно простым. 
Мне просто нужно было использовать точно такие же макросы, которые Diesel использует при генерации моей обычной схемы. 
Сказав это, я стал гораздо больше ценить Diesel на протяжении всего этого опыта. 
Смотрите [Bonus Bug][bonus bug] для всех интересных подробностей.

[diesel view]: https://deterministic.space/diesel-view-table-trick.html

[thresholds]: /ru/docs/explanation/thresholds/

[bonus bug]: #bonus-bug