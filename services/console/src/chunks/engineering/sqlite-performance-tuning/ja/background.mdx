## 背景

最初から、[Bencher Perf API][perf query]が性能的にもっとも要求されるエンドポイントの一つになることは明らかでした。
多くの人々が[ベンチマーク追跡ホイールを再発明][prior art]しなければならなかった主な理由は、既存のオフ・ザ・シェルフツールが必要とされる高い次元性を扱えないからだと考えています。
「高い次元性」とは、時間を超えて、そして複数の次元：[ブランチ][branch]、[テストベッド][testbed]、[ベンチマーク][benchmarks]、そして[測定][measures]を渡って性能を追跡できる能力のことを指します。
この5つの異なる次元をまたいでスライスしダイスする能力は、非常に複雑なモデルにつながります。

この本質的な複雑さとデータの性質のために、Bencher用に時系列データベースを使用することを検討しました。
しかし最終的に、SQLiteを使用することに落ち着きました。
スケールしないことを[行う][do things that dont scale]方が、実際に助けになるかどうかわからない完全に新しいデータベースアーキテクチャを学ぶために余計な時間を費やすよりも良いと判断しました。

時間が経つにつれて、Bencher Perf APIに対する要求も増えてきました。
元々は、プロットしたい次元をすべて手動で選択する必要がありました。
これは、ユーザーが有用なプロットにたどり着くための大きな摩擦を生み出しました。
これを解決するために、Perfページに[最も最近のレポートのリストを追加し][github issue 133]、デフォルトでは最も最近のレポートが選択されてプロットされるようにしました。
これは、最も最近の報告書に112個のベンチマークがある場合、その全部がプロットされることを意味します。
[閾値の境界][thresholds]を追跡して視覚化する能力も複雑さをさらに増す要因となりました。

これを踏まえて、いくつかのパフォーマンス関連の改善を行いました。
Perfプロットは最も最近のレポートからプロットを開始する必要があるため、[レポートAPI][reports api]をリファクタリングして、データベースへの単一の呼び出しでレポートの結果データを取得できるようにしました。反復する代わりです。
デフォルトのレポートクエリーの時間ウィンドウは、無制限ではなく、4週間に設定されました。
また、データベースハンドルの範囲を大幅に制限し、ロックの競合を軽減しました。
ユーザーとのコミュニケーションを助けるために、[Perfプロット][bencher v0317]と[次元タブ][bencher v045]の両方にステータスバーのスピナーを追加しました。

昨秋、四重ネストしたforループの代わりに全てのPerf結果を単一のクエリで取得するコンポジットクエリを試みましたが、失敗しました。
これは私が[Rust型システムの再帰限界][recusion limit]に達し、
スタックを繰り返しオーバーフローさせ、
38秒よりもはるかに長い（信じられないほど長い）コンパイル時間を苦しんで、
最終的には[SQLiteの合成セレクト文の最大項数の限界][sqlite limits]で行き詰まりました。

これら全ての経験を積んで、私はここで本格的に取り組み、パフォーマンスエンジニアの立場を固める必要があると知りました。
私は以前にSQLiteデータベースをプロファイリングしたことがなく、
正直なところ、_どんな_データベースをプロファイリングしたこともありませんでした。
ちょっと待ってください。[私のLinkedInプロファイル][linkedin epompeii]では、ほぼ2年間「データベース管理者」だったって書いてありますよね。
そして、_一度も_データベースのプロファイリングをしたことがないって‽
ええ、それはまた別の話でしょうね。