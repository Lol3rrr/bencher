## Materialized View

When I added the ability to track and visualize [Threshold Boundaries][thresholds] last year,
I had a decision to make in the database model.
There is a 1-to-0/1 relationship between a Metric and its corresponding Boundary.
That is a Metric can relate to zero or one Boundary, and a Boundary can only ever relate to one Metric.
So I could have just expanded the `metric` table to include all of the `boundary` data with every `boundary` related field being nullable.
Or I could create a separate `boundary` table with a `UNIQUE` foreign key to `metric` table.
To me the latter option felt a lot cleaner, and I figured I could always deal with any performance implications later.

These were the effective queries used to create the `metric` and `boundary` tables:

```sql
CREATE TABLE metric (
    id INTEGER PRIMARY KEY NOT NULL,
    uuid TEXT NOT NULL UNIQUE,
    report_benchmark_id INTEGER NOT NULL,
    measure_id INTEGER NOT NULL,
    value DOUBLE NOT NULL,
    lower_value DOUBLE,
    upper_value DOUBLE,
    FOREIGN KEY (report_benchmark_id) REFERENCES report_benchmark (id) ON DELETE CASCADE,
    FOREIGN KEY (measure_id) REFERENCES measure (id),
    UNIQUE(report_benchmark_id, measure_id)
);
```

```sql
CREATE TABLE boundary (
    id INTEGER PRIMARY KEY NOT NULL,
    uuid TEXT NOT NULL UNIQUE,
    threshold_id INTEGER NOT NULL,
    statistic_id INTEGER NOT NULL,
    metric_id INTEGER NOT NULL UNIQUE,
    baseline DOUBLE NOT NULL,
    lower_limit DOUBLE,
    upper_limit DOUBLE,
    FOREIGN KEY (threshold_id) REFERENCES threshold (id),
    FOREIGN KEY (statistic_id) REFERENCES statistic (id),
    FOREIGN KEY (metric_id) REFERENCES metric (id) ON DELETE CASCADE
);
```

And it turns out "later" had arrived.
I tried to simply add an index for `boundary(metric_id)` but that did not help.
I believe the reason has to do with the fact that the Perf query is originating from the `metric` table
and because that relationship is 0/1 or put another way, nullable it has to be scanned (O(n))
and cannot be searched (O(log(n))).

This left me with one clear option.
I needed to create a materialized view that flattened the `metric` and `boundary` relationship
to keep SQLite from having to create an on-the-fly materialized view.

This is the query I used to create the new `metric_boundary` materialized view:

```sql
CREATE VIEW metric_boundary AS
SELECT metric.id AS metric_id,
    metric.uuid AS metric_uuid,
    metric.report_benchmark_id,
    metric.measure_id,
    metric.value,
    metric.lower_value,
    metric.upper_value,
    boundary.id,
    boundary.uuid AS boundary_uuid,
    boundary.threshold_id AS threshold_id,
    boundary.model_id,
    boundary.baseline,
    boundary.lower_limit,
    boundary.upper_limit
FROM metric
    LEFT OUTER JOIN boundary ON (boundary.metric_id = metric.id);
```

With this solution, I'm trading off space for runtime performance.
How much space?
Surprisingly only about a 4% increase, even though this view is for the two largest tables in the database.
Best of all, it lets me have my cake and eat it too in my source code.

[Creating a materialized view with Diesel][diesel view] was surprisingly easy.
I just had to use the exact same macros that Diesel uses when generating my normal schema.
With that said, I learned to appreciate Diesel a lot more throughout this experience.
See [Bonus Bug][bonus bug] for all the juicy details.

[diesel view]: https://deterministic.space/diesel-view-table-trick.html

[thresholds]: /docs/explanation/thresholds/

[bonus bug]: #bonus-bug
